// Code generated by sqlc. DO NOT EDIT.
// source: questions.sql

package db

import (
	"context"
)

const createQuestion = `-- name: CreateQuestion :one
INSERT INTO questions (
    challenge_name,
    description,
    example,
    difficulty,
    complexity,
    completion_time,
    question_type
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, challenge_name, description, example, difficulty, complexity, completion_time, question_type, created_at, updated_at
`

type CreateQuestionParams struct {
	ChallengeName  string       `json:"challenge_name"`
	Description    string       `json:"description"`
	Example        string       `json:"example"`
	Difficulty     int32        `json:"difficulty"`
	Complexity     string       `json:"complexity"`
	CompletionTime int32        `json:"completion_time"`
	QuestionType   QuestionType `json:"question_type"`
}

func (q *Queries) CreateQuestion(ctx context.Context, arg CreateQuestionParams) (Question, error) {
	row := q.db.QueryRowContext(ctx, createQuestion,
		arg.ChallengeName,
		arg.Description,
		arg.Example,
		arg.Difficulty,
		arg.Complexity,
		arg.CompletionTime,
		arg.QuestionType,
	)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.ChallengeName,
		&i.Description,
		&i.Example,
		&i.Difficulty,
		&i.Complexity,
		&i.CompletionTime,
		&i.QuestionType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteQuestion = `-- name: DeleteQuestion :exec
DELETE FROM questions
where id = $1
`

func (q *Queries) DeleteQuestion(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteQuestion, id)
	return err
}

const getQuestion = `-- name: GetQuestion :one
SELECT id, challenge_name, description, example, difficulty, complexity, completion_time, question_type, created_at, updated_at from questions
where id = $1 LIMIT 1
`

func (q *Queries) GetQuestion(ctx context.Context, id int64) (Question, error) {
	row := q.db.QueryRowContext(ctx, getQuestion, id)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.ChallengeName,
		&i.Description,
		&i.Example,
		&i.Difficulty,
		&i.Complexity,
		&i.CompletionTime,
		&i.QuestionType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAllQuestions = `-- name: ListAllQuestions :many
SELECT id, challenge_name, description, example, difficulty, complexity, completion_time, question_type, created_at, updated_at from questions
ORDER BY ASCENDING(difficulty)
LIMIT $1
OFFSET $2
`

type ListAllQuestionsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAllQuestions(ctx context.Context, arg ListAllQuestionsParams) ([]Question, error) {
	rows, err := q.db.QueryContext(ctx, listAllQuestions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Question{}
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.ChallengeName,
			&i.Description,
			&i.Example,
			&i.Difficulty,
			&i.Complexity,
			&i.CompletionTime,
			&i.QuestionType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllQuestionsByDifficulty = `-- name: ListAllQuestionsByDifficulty :many
SELECT id, challenge_name, description, example, difficulty, complexity, completion_time, question_type, created_at, updated_at from questions
where difficulty = $1
ORDER BY ASCENDING(difficulty)
LIMIT $2
OFFSET $3
`

type ListAllQuestionsByDifficultyParams struct {
	Difficulty int32 `json:"difficulty"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

func (q *Queries) ListAllQuestionsByDifficulty(ctx context.Context, arg ListAllQuestionsByDifficultyParams) ([]Question, error) {
	rows, err := q.db.QueryContext(ctx, listAllQuestionsByDifficulty, arg.Difficulty, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Question{}
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.ChallengeName,
			&i.Description,
			&i.Example,
			&i.Difficulty,
			&i.Complexity,
			&i.CompletionTime,
			&i.QuestionType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllQuestionsByType = `-- name: ListAllQuestionsByType :many
SELECT id, challenge_name, description, example, difficulty, complexity, completion_time, question_type, created_at, updated_at from questions
where question_type = $1
ORDER BY ASCENDING(difficulty)
LIMIT $2
OFFSET $3
`

type ListAllQuestionsByTypeParams struct {
	QuestionType QuestionType `json:"question_type"`
	Limit        int32        `json:"limit"`
	Offset       int32        `json:"offset"`
}

func (q *Queries) ListAllQuestionsByType(ctx context.Context, arg ListAllQuestionsByTypeParams) ([]Question, error) {
	rows, err := q.db.QueryContext(ctx, listAllQuestionsByType, arg.QuestionType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Question{}
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.ChallengeName,
			&i.Description,
			&i.Example,
			&i.Difficulty,
			&i.Complexity,
			&i.CompletionTime,
			&i.QuestionType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateQuestion = `-- name: UpdateQuestion :one
UPDATE questions
SET challenge_name = $2, description = $3,
example = $4, difficulty = $5, complexity = $6, 
completion_time = $7 where id = $1
RETURNING id, challenge_name, description, example, difficulty, complexity, completion_time, question_type, created_at, updated_at
`

type UpdateQuestionParams struct {
	ID             int64  `json:"id"`
	ChallengeName  string `json:"challenge_name"`
	Description    string `json:"description"`
	Example        string `json:"example"`
	Difficulty     int32  `json:"difficulty"`
	Complexity     string `json:"complexity"`
	CompletionTime int32  `json:"completion_time"`
}

func (q *Queries) UpdateQuestion(ctx context.Context, arg UpdateQuestionParams) (Question, error) {
	row := q.db.QueryRowContext(ctx, updateQuestion,
		arg.ID,
		arg.ChallengeName,
		arg.Description,
		arg.Example,
		arg.Difficulty,
		arg.Complexity,
		arg.CompletionTime,
	)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.ChallengeName,
		&i.Description,
		&i.Example,
		&i.Difficulty,
		&i.Complexity,
		&i.CompletionTime,
		&i.QuestionType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
